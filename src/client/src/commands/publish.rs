use anyhow::{bail, Context, Result};
use colored::Colorize;

use crate::config::Config;
use crate::ipfs;

pub async fn run_publish(kind: &str, id: &str) -> Result<()> {
    let config = Config::load()?;

    if config.ipfs.api_url.is_empty() || config.ipfs.api_key.is_empty() {
        bail!(
            "IPFS not configured. Add [ipfs] section to config.toml with api_url and api_key.\n\
             Example:\n  [ipfs]\n  api_url = \"https://api.pinata.cloud\"\n  api_key = \"your-jwt-token\""
        );
    }

    let (base_dir, archive_name, nft_name) = match kind {
        "contribution" => {
            let dir = Config::contributions_dir()?.join(id);
            (dir, "proofs.tar.gz", "nft_metadata.json")
        }
        "certificate" => {
            let dir = Config::config_dir()?.join("certifications").join(id);
            (
                dir,
                "certification_package.tar.gz",
                "certification_nft_metadata.json",
            )
        }
        _ => bail!(
            "Unknown type '{}'. Use 'contribution' or 'certificate'.",
            kind
        ),
    };

    if !base_dir.exists() {
        bail!("{} directory not found: {}", kind, base_dir.display());
    }

    let archive_path = base_dir.join(archive_name);
    let nft_path = base_dir.join(nft_name);

    if !archive_path.exists() {
        bail!("Archive not found: {}", archive_path.display());
    }
    if !nft_path.exists() {
        bail!(
            "NFT metadata not found: {}. Run the {} first.",
            nft_path.display(),
            if kind == "contribution" {
                "prove"
            } else {
                "certify seal"
            }
        );
    }

    println!("{}", "=== Proof@Home Publish ===".bold().cyan());
    println!("Type: {}", kind);
    println!("ID:   {}", id);
    println!();

    // 1. Pin archive to IPFS
    print!("Pinning archive to IPFS... ");
    let archive_cid = ipfs::pin_to_ipfs(&archive_path, &config.ipfs.api_url, &config.ipfs.api_key)
        .await
        .context("Failed to pin archive")?;
    println!("{} ({})", "OK".green(), &archive_cid);

    // 2. Load and update metadata with external_url
    let nft_content = std::fs::read_to_string(&nft_path)?;
    let mut nft_json: serde_json::Value = serde_json::from_str(&nft_content)?;
    nft_json["external_url"] = serde_json::Value::String(format!("ipfs://{}", archive_cid));

    // Add Archive IPFS CID attribute
    if let Some(attrs) = nft_json["attributes"].as_array_mut() {
        attrs.push(serde_json::json!({
            "trait_type": "Archive IPFS CID",
            "value": archive_cid
        }));
    }

    // 3. Pin metadata JSON to IPFS
    print!("Pinning metadata to IPFS... ");
    let metadata_cid =
        ipfs::pin_json_to_ipfs(&nft_json, &config.ipfs.api_url, &config.ipfs.api_key)
            .await
            .context("Failed to pin metadata")?;
    println!("{} ({})", "OK".green(), &metadata_cid);

    // 4. Write mint_ready.json
    let token_uri = format!("ipfs://{}", metadata_cid);
    let mint_ready = serde_json::json!({
        "metadata_cid": metadata_cid,
        "archive_cid": archive_cid,
        "token_uri": token_uri,
        "contract_address": ""
    });

    let mint_ready_path = base_dir.join("mint_ready.json");
    std::fs::write(&mint_ready_path, serde_json::to_string_pretty(&mint_ready)?)?;

    // 5. Save updated NFT metadata
    let published_nft_path = base_dir.join("nft_metadata_published.json");
    std::fs::write(
        &published_nft_path,
        serde_json::to_string_pretty(&nft_json)?,
    )?;

    // 6. Generate mint.sh script
    let mint_script_path = base_dir.join("mint.sh");
    let mint_script = format!(
        r#"#!/usr/bin/env bash
# Proof@Home — Mint NFT on-chain
#
# Prerequisites:
#   1. Install Foundry: curl -L https://foundry.paradigm.xyz | bash && foundryup
#   2. Deploy ProofAtHome.sol (see contracts/README.md)
#   3. Set the environment variables below
#
# Usage:
#   chmod +x mint.sh
#   ./mint.sh

set -euo pipefail

# ── Configuration (edit these) ──────────────────────────────────────────────
CONTRACT_ADDRESS="${{CONTRACT_ADDRESS:?Set CONTRACT_ADDRESS to your deployed ProofAtHome contract}}"
RECIPIENT="${{RECIPIENT:?Set RECIPIENT to the wallet address that will own the NFT}}"
RPC_URL="${{RPC_URL:?Set RPC_URL to your Ethereum RPC endpoint (e.g. https://base-mainnet.g.alchemy.com/v2/KEY)}}"
DEPLOYER_KEY="${{DEPLOYER_KEY:?Set DEPLOYER_KEY to the contract owner's private key}}"

# ── Mint data (auto-generated by proof-at-home publish) ─────────────────────
TOKEN_URI="{token_uri}"

# ── Mint ────────────────────────────────────────────────────────────────────
echo "Minting NFT..."
echo "  Contract:  $CONTRACT_ADDRESS"
echo "  Recipient: $RECIPIENT"
echo "  Token URI: $TOKEN_URI"
echo "  RPC:       $RPC_URL"
echo ""

cast send "$CONTRACT_ADDRESS" \
  "mint(address,string)" \
  "$RECIPIENT" \
  "$TOKEN_URI" \
  --rpc-url "$RPC_URL" \
  --private-key "$DEPLOYER_KEY"

echo ""
echo "Done. NFT minted successfully."
echo "View on block explorer or OpenSea to confirm."
"#
    );

    std::fs::write(&mint_script_path, &mint_script)?;
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        std::fs::set_permissions(&mint_script_path, std::fs::Permissions::from_mode(0o755))?;
    }

    println!();
    println!("{}", "=== Published ===".bold().green());
    println!("Token URI:  {}", token_uri.cyan());
    println!("Archive:    ipfs://{}", archive_cid);
    println!("Metadata:   ipfs://{}", metadata_cid);
    println!("Mint ready: {}", mint_ready_path.display());
    println!("Mint script: {}", mint_script_path.display());
    println!();
    println!(
        "To mint on-chain, set env vars and run: {}",
        "./mint.sh".cyan()
    );

    Ok(())
}
