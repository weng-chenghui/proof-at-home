use anyhow::{Context, Result};
use colored::Colorize;
use serde::Deserialize;
use std::io::BufRead;
use std::path::Path;

use crate::config::Config;
use crate::nft::metadata::{generate_submitter_nft_metadata, ConjectureSubmitterInfo};
use crate::server_client::api::{
    Conjecture, ConjectureCreateResponse, Dependencies, LeanDeps, ServerClient,
};
use crate::signing;

// ── LeanConjecturer types ──
// Credit: auto-res/LeanConjecturer (MIT) — https://github.com/auto-res/LeanConjecturer

/// LeanConjecturer entry from grpo_problem.jsonl.
#[derive(Debug, Deserialize)]
struct LeanConjecturerEntry {
    conjecture: LcConjecture,
    already_exists: bool,
    #[serde(default)]
    #[allow(dead_code)]
    aesop_provable: bool,
    error: Option<serde_json::Value>,
    goal: Option<String>,
    id: String,
}

#[derive(Debug, Deserialize)]
struct LcConjecture {
    code: String,
    generate_err: Option<String>,
}

// ── LeanConjecturer helpers ──

/// Split Lean code at the first `theorem`, `lemma`, or `def` line.
/// Returns (preamble, statement). If no keyword found, preamble is empty.
fn split_lean_code(code: &str) -> (String, String) {
    let keywords = ["theorem ", "lemma ", "def "];
    for (i, line) in code.lines().enumerate() {
        let trimmed = line.trim_start();
        if keywords.iter().any(|kw| trimmed.starts_with(kw)) {
            let preamble: String = code.lines().take(i).collect::<Vec<_>>().join("\n");
            let statement: String = code.lines().skip(i).collect::<Vec<_>>().join("\n");
            return (preamble.trim().to_string(), statement.trim().to_string());
        }
    }
    (String::new(), code.trim().to_string())
}

/// Extract the theorem/lemma/def name from the first line of a statement.
fn extract_theorem_name(stmt: &str) -> Option<String> {
    let first_line = stmt.lines().next()?;
    let trimmed = first_line.trim_start();
    // Skip keyword
    let rest = trimmed
        .strip_prefix("theorem ")
        .or_else(|| trimmed.strip_prefix("lemma "))
        .or_else(|| trimmed.strip_prefix("def "))?;
    // Name is up to first whitespace, '(', '{', ':', or '['
    let name: String = rest
        .chars()
        .take_while(|c| !c.is_whitespace() && *c != '(' && *c != '{' && *c != ':' && *c != '[')
        .collect();
    if name.is_empty() {
        None
    } else {
        Some(name)
    }
}

/// Convert a snake_case name into Title Case.
fn snake_to_title(name: &str) -> String {
    name.split('_')
        .filter(|s| !s.is_empty())
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                Some(c) => {
                    let upper: String = c.to_uppercase().collect();
                    format!("{}{}", upper, chars.as_str())
                }
                None => String::new(),
            }
        })
        .collect::<Vec<_>>()
        .join(" ")
}

/// Replace proof body with `sorry`.
fn make_skeleton(stmt: &str) -> String {
    // Look for `:= by` and replace everything after it
    if let Some(pos) = stmt.find(":= by") {
        format!("{}\n  sorry", &stmt[..pos + ":= by".len()])
    } else if let Some(pos) = stmt.find(":= begin") {
        format!("{}\n  sorry\nend", &stmt[..pos + ":= begin".len()])
    } else {
        // Append sorry as-is
        format!("{}\n  sorry", stmt.trim_end())
    }
}

/// Convert a single LeanConjecturer entry to a Proof@Home Conjecture.
/// Returns None if entry should be skipped (errors, already_exists, etc.).
fn convert_lc_entry(entry: &LeanConjecturerEntry, difficulty: &str) -> Option<Conjecture> {
    // Skip entries with errors
    if entry.conjecture.generate_err.is_some() {
        return None;
    }
    if entry.error.is_some() {
        return None;
    }
    if entry.already_exists {
        return None;
    }

    let code = &entry.conjecture.code;
    if code.trim().is_empty() {
        return None;
    }

    let (preamble, lemma_statement) = split_lean_code(code);
    let skeleton = make_skeleton(&lemma_statement);

    let title = extract_theorem_name(&lemma_statement)
        .map(|n| snake_to_title(&n))
        .unwrap_or_else(|| format!("LeanConjecturer {}", &entry.id[..8.min(entry.id.len())]));

    let mut hints = Vec::new();
    if let Some(goal) = &entry.goal {
        if !goal.is_empty() {
            hints.push(format!("Goal: {}", goal));
        }
    }
    hints.push("Generated by LeanConjecturer (auto-res, MIT)".to_string());

    Some(Conjecture {
        id: entry.id.clone(),
        title,
        difficulty: difficulty.to_string(),
        prover: "lean4".to_string(),
        status: "open".to_string(),
        preamble,
        lemma_statement,
        hints,
        skeleton,
        dependencies: Some(Dependencies::Lean(LeanDeps {
            lean_toolchain: "leanprover/lean4:v4.16.0".to_string(),
            lake_packages: vec!["mathlib".to_string()],
        })),
    })
}

const LC_ATTRIBUTION: &str =
    "LeanConjecturer by auto-res (MIT license) — https://github.com/auto-res/LeanConjecturer";

pub async fn cmd_list() -> Result<()> {
    let cfg = Config::load_or_default();
    cfg.require_login()?;
    let client = ServerClient::new(&cfg.server_url(), &cfg.api.auth_token);
    let conjectures = client.fetch_conjectures().await?;

    if conjectures.is_empty() {
        println!("No conjectures found.");
        return Ok(());
    }

    println!(
        "{:<40} {:<30} {:<12} {:<10} {:<10}",
        "ID", "Title", "Difficulty", "Prover", "Status"
    );
    println!("{}", "-".repeat(102));

    for c in &conjectures {
        let display_id = if c.id.len() > 36 { &c.id[..36] } else { &c.id };
        let display_title = if c.title.len() > 28 {
            format!("{}…", &c.title[..27])
        } else {
            c.title.clone()
        };
        println!(
            "{:<40} {:<30} {:<12} {:<10} {:<10}",
            display_id, display_title, c.difficulty, c.prover, c.status
        );
    }

    println!("\nTotal: {}", conjectures.len());
    Ok(())
}

pub async fn cmd_get(id: &str) -> Result<()> {
    let cfg = Config::load_or_default();
    cfg.require_login()?;
    let client = ServerClient::new(&cfg.server_url(), &cfg.api.auth_token);
    let c = client.fetch_conjecture(id).await?;

    println!("{}", "=== Conjecture ===".bold());
    println!("ID:         {}", c.id);
    println!("Title:      {}", c.title);
    println!("Difficulty: {}", c.difficulty);
    println!("Prover:     {}", c.prover);
    println!("Status:     {}", c.status);
    if !c.preamble.is_empty() {
        println!("\nPreamble:\n{}", c.preamble);
    }
    if !c.lemma_statement.is_empty() {
        println!("\nLemma Statement:\n{}", c.lemma_statement);
    }
    if !c.hints.is_empty() {
        println!("\nHints:");
        for h in &c.hints {
            println!("  - {}", h);
        }
    }
    if !c.skeleton.is_empty() {
        println!("\nSkeleton:\n{}", c.skeleton);
    }

    Ok(())
}

pub async fn cmd_create(source: &str) -> Result<()> {
    let cfg = Config::load_or_default();
    cfg.require_login()?;
    let client = ServerClient::new(&cfg.server_url(), &cfg.api.auth_token);

    let resp = if is_git_url(source) {
        println!("{} Submitting git URL: {}", "→".blue(), source);
        client.create_conjecture_git_url(source).await?
    } else {
        let path = Path::new(source);
        if !path.exists() {
            anyhow::bail!("Source path does not exist: {}", source);
        }

        if path.is_dir() {
            println!("{} Packaging directory: {}", "→".blue(), source);
            let tar_bytes = tar_directory(path)?;
            client.create_conjecture_tar(tar_bytes).await?
        } else if source.ends_with(".tar.gz") || source.ends_with(".tgz") {
            println!("{} Submitting archive: {}", "→".blue(), source);
            let tar_bytes =
                std::fs::read(path).with_context(|| format!("Failed to read {}", source))?;
            client.create_conjecture_tar(tar_bytes).await?
        } else {
            anyhow::bail!(
                "Unsupported source: {}. Expected a directory, .tar.gz file, or git URL.",
                source
            );
        }
    };

    print_result(&resp);
    seal_submitter_nft(&cfg, &client, &resp).await?;

    Ok(())
}

pub async fn cmd_seal(batch_id: &str) -> Result<()> {
    let cfg = Config::load_or_default();
    cfg.require_login()?;
    let client = ServerClient::new(&cfg.server_url(), &cfg.api.auth_token);

    let (public_key, commit_signature) = sign_if_possible(&cfg, batch_id);

    let nft_info = ConjectureSubmitterInfo {
        submitter_username: cfg.identity.username.clone(),
        batch_id: batch_id.to_string(),
        conjectures_submitted: 0,
        conjecture_ids: Vec::new(),
        difficulties: Vec::new(),
        proof_assistants: Vec::new(),
        git_commit: batch_id.to_string(),
        git_repository: cfg.server_url(),
        public_key,
        commit_signature,
        source_attribution: None,
    };

    let nft_metadata = generate_submitter_nft_metadata(&nft_info);

    print!("Sealing conjecture batch (creating PR)... ");
    match client.seal_conjecture_batch(batch_id, &nft_metadata).await {
        Ok(seal_resp) => {
            println!("{}", "OK".green());
            if !seal_resp.pr_url.is_empty() {
                println!("  PR: {}", seal_resp.pr_url.cyan());
            }
        }
        Err(e) => {
            println!("{}", "FAILED".red());
            eprintln!("{}: Could not seal on server: {}", "Warning".yellow(), e);
        }
    }

    println!("\n{}", "=== Conjecture Batch Sealed ===".bold());
    println!("  Batch ID: {}", batch_id);

    Ok(())
}

pub async fn cmd_import(
    jsonl_path: &str,
    difficulty: &str,
    dry_run: bool,
    output_dir: Option<&str>,
) -> Result<()> {
    println!("{} Importing: {}", "→".blue(), LC_ATTRIBUTION);

    let path = Path::new(jsonl_path);
    if !path.exists() {
        anyhow::bail!("JSONL file does not exist: {}", jsonl_path);
    }

    let out_dir = match output_dir {
        Some(d) => {
            std::fs::create_dir_all(d)
                .with_context(|| format!("Failed to create output dir: {}", d))?;
            std::path::PathBuf::from(d)
        }
        None => {
            let dir = std::env::temp_dir().join(format!("pah-lc-{}", uuid::Uuid::new_v4()));
            std::fs::create_dir_all(&dir).context("Failed to create temp directory")?;
            dir
        }
    };

    let file =
        std::fs::File::open(path).with_context(|| format!("Failed to open {}", jsonl_path))?;
    let reader = std::io::BufReader::new(file);

    let mut converted = 0u32;
    let mut skipped = 0u32;

    for (line_num, line) in reader.lines().enumerate() {
        let line = line.with_context(|| format!("Failed to read line {}", line_num + 1))?;
        let line = line.trim();
        if line.is_empty() {
            continue;
        }

        let entry: LeanConjecturerEntry = match serde_json::from_str(line) {
            Ok(e) => e,
            Err(e) => {
                eprintln!("{}: line {}: {}", "Warning".yellow(), line_num + 1, e);
                skipped += 1;
                continue;
            }
        };

        match convert_lc_entry(&entry, difficulty) {
            Some(conjecture) => {
                let json_path = out_dir.join(format!("{}.json", conjecture.id));
                let json = serde_json::to_string_pretty(&conjecture)
                    .context("Failed to serialize conjecture")?;
                std::fs::write(&json_path, json)
                    .with_context(|| format!("Failed to write {}", json_path.display()))?;
                converted += 1;
            }
            None => {
                skipped += 1;
            }
        }
    }

    println!(
        "{} Converted {} conjecture(s), skipped {}",
        "✓".green(),
        converted,
        skipped
    );
    println!("  Output: {}", out_dir.display());

    if dry_run {
        println!("{} Dry run — not submitting to server.", "ℹ".blue());
        return Ok(());
    }

    if converted == 0 {
        println!("No conjectures to submit.");
        return Ok(());
    }

    cmd_create(out_dir.to_str().unwrap()).await
}

pub async fn cmd_generate(
    source: &str,
    bin: Option<&str>,
    extra_args: &[String],
    difficulty: &str,
    dry_run: bool,
    output_dir: Option<&str>,
) -> Result<()> {
    println!(
        "{} Generating conjectures with LeanConjecturer (auto-res, MIT license)",
        "→".blue()
    );
    println!(
        "  {}",
        "https://github.com/auto-res/LeanConjecturer".dimmed()
    );

    // Locate binary
    let binary = match bin {
        Some(b) => {
            if !Path::new(b).exists() {
                anyhow::bail!("LeanConjecturer binary not found at: {}", b);
            }
            b.to_string()
        }
        None => {
            let info = crate::tools::registry::require_tool("lean_conjecturer")?;
            info.path.to_string_lossy().to_string()
        }
    };

    println!("  Binary: {}", binary);
    println!("  Source: {}", source);

    // Shell out
    let mut cmd = std::process::Command::new(&binary);
    cmd.arg(source);
    for arg in extra_args {
        cmd.arg(arg);
    }

    let status = cmd
        .status()
        .with_context(|| format!("Failed to execute {}", binary))?;

    if !status.success() {
        anyhow::bail!(
            "LeanConjecturer exited with status {}",
            status.code().unwrap_or(-1)
        );
    }

    // Find grpo_problem.jsonl in output
    let jsonl_candidates = [
        "grpo_problem.jsonl",
        "output/grpo_problem.jsonl",
        "results/grpo_problem.jsonl",
    ];

    let jsonl_path = jsonl_candidates
        .iter()
        .find(|p| Path::new(p).exists())
        .ok_or_else(|| {
            anyhow::anyhow!(
                "Could not find grpo_problem.jsonl after running LeanConjecturer. \
                 Expected in current directory or output/ subdirectory."
            )
        })?;

    println!("{} Found output: {}", "✓".green(), jsonl_path);

    cmd_import(jsonl_path, difficulty, dry_run, output_dir).await
}

// ── Helpers ──

async fn seal_submitter_nft(
    cfg: &Config,
    client: &ServerClient,
    resp: &ConjectureCreateResponse,
) -> Result<()> {
    let commit_sha = &resp.commit_sha;

    let (public_key, commit_signature) = sign_if_possible(cfg, commit_sha);

    let nft_info = ConjectureSubmitterInfo {
        submitter_username: cfg.identity.username.clone(),
        batch_id: resp.batch_id.clone(),
        conjectures_submitted: resp.count,
        conjecture_ids: resp.added_conjecture_ids.clone(),
        difficulties: resp.difficulties.clone(),
        proof_assistants: resp.proof_assistants.clone(),
        git_commit: commit_sha.clone(),
        git_repository: cfg.server_url(),
        public_key,
        commit_signature,
        source_attribution: None,
    };

    let nft_metadata = generate_submitter_nft_metadata(&nft_info);

    print!("Sealing conjecture submission (creating PR)... ");
    match client
        .seal_conjecture_batch(&resp.batch_id, &nft_metadata)
        .await
    {
        Ok(seal_resp) => {
            println!("{}", "OK".green());
            if !seal_resp.pr_url.is_empty() {
                println!("  PR: {}", seal_resp.pr_url.cyan());
            }
        }
        Err(e) => {
            println!("{}", "FAILED".red());
            eprintln!("{}: Could not seal on server: {}", "Warning".yellow(), e);
        }
    }

    println!("\n{}", "=== Conjecture Submission Sealed ===".bold());
    println!("  Batch ID:    {}", resp.batch_id);
    println!("  Git Commit:  {}", commit_sha);
    println!("  Conjectures: {}", resp.count);

    Ok(())
}

fn sign_if_possible(cfg: &Config, commit_sha: &str) -> (String, String) {
    match Config::signing_key_path()
        .ok()
        .filter(|p| p.exists())
        .and_then(|p| std::fs::read_to_string(&p).ok())
    {
        Some(key_hex) => match signing::load_signing_key(&key_hex) {
            Ok(key) => {
                let sig = signing::sign_commit(&key, commit_sha).unwrap_or_default();
                (cfg.identity.public_key.clone(), sig)
            }
            Err(e) => {
                eprintln!("{}: Could not load signing key: {}", "Warning".yellow(), e);
                (String::new(), String::new())
            }
        },
        None => {
            eprintln!(
                "{}: No signing key found. Run `pah setting set` to generate one.",
                "Warning".yellow()
            );
            (String::new(), String::new())
        }
    }
}

fn is_git_url(source: &str) -> bool {
    source.starts_with("http://")
        || source.starts_with("https://")
        || source.starts_with("git@")
        || source.starts_with("git://")
}

fn tar_directory(dir: &Path) -> Result<Vec<u8>> {
    use flate2::write::GzEncoder;
    use flate2::Compression;
    use std::fs;
    use tar::Builder;

    let buf = Vec::new();
    let enc = GzEncoder::new(buf, Compression::default());
    let mut ar = Builder::new(enc);

    for entry in fs::read_dir(dir).context("Failed to read directory")? {
        let entry = entry?;
        let path = entry.path();
        if path.is_file() && path.extension().and_then(|e| e.to_str()) == Some("json") {
            let name = entry.file_name();
            ar.append_path_with_name(&path, &name)
                .with_context(|| format!("Failed to add {} to archive", path.display()))?;
        }
    }

    let enc = ar.into_inner().context("Failed to finish tar archive")?;
    let bytes = enc.finish().context("Failed to finish gzip")?;
    Ok(bytes)
}

fn print_result(resp: &ConjectureCreateResponse) {
    println!("{} {} conjecture(s) added", "✓".green(), resp.count);
    if !resp.added_conjecture_ids.is_empty() {
        println!("  IDs: {}", resp.added_conjecture_ids.join(", "));
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_valid_entry() -> LeanConjecturerEntry {
        LeanConjecturerEntry {
            conjecture: LcConjecture {
                code: "import Mathlib.Data.Nat.Basic\n\ntheorem add_comm_custom (n m : Nat) : n + m = m + n := by\n  omega".to_string(),
                generate_err: None,
            },
            already_exists: false,
            aesop_provable: false,
            error: None,
            goal: Some("n + m = m + n".to_string()),
            id: "a1b2c3d4-e5f6-7890-abcd-ef1234567890".to_string(),
        }
    }

    #[test]
    fn test_convert_valid_entry() {
        let entry = make_valid_entry();
        let result = convert_lc_entry(&entry, "medium");
        assert!(result.is_some());
        let c = result.unwrap();
        assert_eq!(c.id, "a1b2c3d4-e5f6-7890-abcd-ef1234567890");
        assert_eq!(c.title, "Add Comm Custom");
        assert_eq!(c.difficulty, "medium");
        assert_eq!(c.prover, "lean4");
        assert_eq!(c.preamble, "import Mathlib.Data.Nat.Basic");
        assert!(c.lemma_statement.starts_with("theorem add_comm_custom"));
        assert!(c.skeleton.contains("sorry"));
        assert!(c.hints.iter().any(|h| h.starts_with("Goal:")));
        assert!(c.hints.iter().any(|h| h.contains("LeanConjecturer")));
    }

    #[test]
    fn test_skip_entry_with_error() {
        let mut entry = make_valid_entry();
        entry.error = Some(serde_json::json!("some error"));
        assert!(convert_lc_entry(&entry, "auto").is_none());
    }

    #[test]
    fn test_skip_already_exists() {
        let mut entry = make_valid_entry();
        entry.already_exists = true;
        assert!(convert_lc_entry(&entry, "auto").is_none());
    }

    #[test]
    fn test_skip_generate_err() {
        let mut entry = make_valid_entry();
        entry.conjecture.generate_err = Some("failed".to_string());
        assert!(convert_lc_entry(&entry, "auto").is_none());
    }

    #[test]
    fn test_split_lean_code() {
        let code = "import Mathlib\nopen Nat\n\ntheorem foo : True := by trivial";
        let (preamble, stmt) = split_lean_code(code);
        assert_eq!(preamble, "import Mathlib\nopen Nat");
        assert!(stmt.starts_with("theorem foo"));
    }

    #[test]
    fn test_split_lean_code_no_preamble() {
        let code = "theorem bar : True := by trivial";
        let (preamble, stmt) = split_lean_code(code);
        assert!(preamble.is_empty());
        assert!(stmt.starts_with("theorem bar"));
    }

    #[test]
    fn test_extract_theorem_name() {
        assert_eq!(
            extract_theorem_name("theorem foo_bar (n : Nat) : True"),
            Some("foo_bar".to_string())
        );
        assert_eq!(
            extract_theorem_name("lemma my_lemma : True"),
            Some("my_lemma".to_string())
        );
        assert_eq!(
            extract_theorem_name("def helper : Nat := 0"),
            Some("helper".to_string())
        );
    }

    #[test]
    fn test_snake_to_title() {
        assert_eq!(snake_to_title("add_comm_custom"), "Add Comm Custom");
        assert_eq!(snake_to_title("foo"), "Foo");
        assert_eq!(snake_to_title("a_b_c"), "A B C");
    }

    #[test]
    fn test_make_skeleton() {
        let stmt = "theorem foo (n : Nat) : n = n := by\n  rfl";
        let skel = make_skeleton(stmt);
        assert!(skel.contains(":= by"));
        assert!(skel.contains("sorry"));
        assert!(!skel.contains("rfl"));
    }
}
